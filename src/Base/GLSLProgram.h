/**
   @author Shin'ichiro Nakaoka
*/

#ifndef CNOID_BASE_GLSL_PROGRAM_H
#define CNOID_BASE_GLSL_PROGRAM_H

/**
   The following header and the corresponding .c file were generated by OpenGL Loader Generator (glLoadGen)
   with the command: lua LoadGen.lua -style=pointer_c -spec=gl -version=3.3 -profile=core core_3_3.
*/
#include "gl_core_3_3.h"

#include <cnoid/EigenTypes>
#include <vector>
#include <string>
#include <stdexcept>
#include <cstring>

namespace cnoid {

class GLSLProgram
{
public:
    class Exception : public std::runtime_error {
    public:
        Exception(const std::string& msg) : std::runtime_error(msg) { }
    };
    
    GLSLProgram();
    ~GLSLProgram();

    void release();
    void loadVertexShader(const char* filename) throw (Exception);
    void loadFragmentShader(const char* filename) throw (Exception);
    void loadShader(const char* filename, int shaderType) throw(Exception);
    void link() throw (Exception);
    void validate() throw(Exception);
    void use() throw (Exception);
    
    GLint handle() const { return programHandle; }
    bool isLinked() const { return isLinked_; }

    GLuint getUniformLocation(const char* name) const {
        return glGetUniformLocation(programHandle, name);
    }

private:
    GLuint programHandle;
    bool isLinked_;

    GLSLProgram(const GLSLProgram& other) { }
    GLSLProgram& operator=(const GLSLProgram& other) { return *this; }
};


class GLSLUniformBlockBuffer
{
public:
    GLSLUniformBlockBuffer();
    ~GLSLUniformBlockBuffer();
    
    void initialize(GLSLProgram& program, const std::string& blockName);

    GLint getOffset(const char* name);    

    void bind(GLSLProgram& program, GLuint bindingPoint) {
        GLuint blockIndex = glGetUniformBlockIndex(program.handle(), blockName.c_str());
        glUniformBlockBinding(program.handle(), blockIndex, bindingPoint);
    }

    void bindBufferBase(GLuint bindingPoint) {
        glBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, uboHandle);
    }

    void write(GLint offset, float v){
        std::memcpy(&localBuffer[offset], &v, sizeof(v));
    }

    void write(GLint offset, const Vector3f& v){
        std::memcpy(&localBuffer[offset], v.data(), sizeof(v));
    }

    void write(GLint offset, const Vector4f& v){
        std::memcpy(&localBuffer[offset], v.data(), sizeof(v));
    }

    void write(GLint offset, const Matrix3f& M){
        const int s3 = 3 * sizeof(Matrix3f::Scalar);
        const int s4 = 4 * sizeof(Matrix3f::Scalar);
        std::memcpy(&localBuffer[offset       ], &M(0, 0), s3);
        std::memcpy(&localBuffer[offset + s4  ], &M(0, 1), s3);
        std::memcpy(&localBuffer[offset + s4*2], &M(0, 2), s3);
    }

    void write(GLint offset, const Matrix4f& M){
        std::memcpy(&localBuffer[offset], M.data(), sizeof(M));
    }
    
    void write(GLint offset, const Affine3f& T){
        std::memcpy(&localBuffer[offset], T.matrix().data(), sizeof(T));
    }

    void flush(){
        glBindBuffer(GL_UNIFORM_BUFFER, uboHandle);
        glBufferSubData(GL_UNIFORM_BUFFER, 0, localBuffer.size(), &localBuffer[0]);
    }

private:
    GLuint uboHandle;
    GLuint lastProgramHandle;
    std::vector<GLubyte> localBuffer;
    std::string blockName;
};

}

#endif
